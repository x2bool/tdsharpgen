using System;
using System.Linq;

namespace TdLib
{
    class TDFunc
    {
        public string Name { get; set; }
        
        public string Descr { get; set; }
        
        public TDField[] Args { get; set; }
        
        public TDType Result { get; set; }

        private const string fileTemplate = @"using System;
using System.Threading.Tasks;
using Newtonsoft.Json;

namespace TdLib
{
    /// <summary>
    /// Autogenerated TDLib APIs
    /// </summary>
    public static partial class TdApi
    {
%BODY%

%EXTENSION%
    }
}
";

        private const string extensionTemplate = @"
    /// <summary>
    /// %DESCR%
    /// </summary>
    public static Task<%RESULT%> %METHOD%(this Client client%PARAMS%)
    {
        return client.ExecuteAsync(new %CLASS% { %INITS%
        });
    }
";

        private const string paramTemplate = @",
            %TYPE% %NAME% = %VAL%";

        private const string initTemplate = @"
                %NAME% = %VAL%,";
        
        private const string classTemplate = @"
    /// <summary>
    /// %DESCR%
    /// </summary>
    public partial class %CLASS% : %BASE%
    {
%BODY%
    }
";

        private const string propTemplate = @"
        /// <summary>
        /// %DESCR%
        /// </summary>
        [JsonConverter(typeof(%CONV%))]
        [JsonProperty(""%NAME%"")]
        public %TYPE% %PROP% { get; set; }
";

        private const string metaTemplate = @"
        /// <summary>
        /// Data type for serialization
        /// </summary>
        [JsonProperty(""@type"")]
        public override string DataType { get; set; } = ""%TYPE%"";

        /// <summary>
        /// Extra data attached to the message
        /// </summary>
        [JsonProperty(""@extra"")]
        public override string Extra { get; set; }
";
        
        public string Generate()
        {
            var cls = classTemplate
                .Replace("partial class", "class")
                .Replace("%CLASS%", GetTypeName(Name))
                .Replace("%DESCR%", Descr ?? "")
                .Replace("%BASE%", GetSuperName())
                .Replace("%BODY%", GenerateMeta() + GenerateProps());

            var ext = extensionTemplate
                .Replace("%METHOD%", GetTypeName(Name) + "Async")
                .Replace("%CLASS%", GetTypeName(Name))
                .Replace("%DESCR%", Descr ?? "")
                .Replace("%RESULT%", Result.Name)
                .Replace("%PARAMS%", GenerateParams())
                .Replace("%INITS%", GenerateInits());
            
            return fileTemplate
                .Replace("%BODY%", cls)
                .Replace("%EXTENSION%", ext);
        }

        private string GetSuperName()
        {
            return "Function<" + Result.Name + ">";
        }

        private string GenerateMeta()
        {
            return metaTemplate.Replace("%TYPE%", Name);
        }

        private string GenerateProps()
        {
            string props = "";
            
            foreach (var arg in Args)
            {
                var prop = GenerateProp(arg);
                if (prop != null)
                {
                    props += prop;
                }
            }

            return props;
        }

        private string GenerateInits()
        {
            string inits = "";

            foreach (var arg in Args)
            {   
                var init = initTemplate
                    .Replace("%NAME%", GeneratePropName(arg.Name))
                    .Replace("%VAL%", GenerateParamName(arg.Name));

                inits += init;
            }
            
            return inits;
        }

        private string GenerateParams()
        {
            string pars = "";

            foreach (var arg in Args)
            {   
                var par = paramTemplate
                    .Replace("%TYPE%", GenerateType(arg))
                    .Replace("%NAME%", GenerateParamName(arg.Name))
                    .Replace("%VAL%", "default(" + GenerateType(arg) + ")");

                pars += par;
            }

            return pars;
        }

        private string GenerateProp(TDField field)
        {
            return propTemplate
                .Replace("%CONV%", GenerateConv(field))
                .Replace("%TYPE%", GenerateType(field))
                .Replace("%NAME%", field.Name)
                .Replace("%DESCR%", field.Descr ?? "")
                .Replace("%PROP%", GeneratePropName(field.Name));
        }

        private string GenerateConv(TDField field)
        {
            var type = GenerateType(field);
            if (type.StartsWith("Int64"))
            {
                return "Converter.Int64";
            }
            return "Converter";
        }

        private string GenerateParamName(string str)
        {
            var arr = str.ToCharArray();
            arr[0] = arr[0].ToString().ToUpper()[0];
            str = new string(arr);

            str = str
                .Split('_')
                .Select((s, i) =>
                {
                    if (i > 0)
                    {
                        return char.ToUpperInvariant(s[0]) + s.Substring(1, s.Length - 1);
                    }
                    
                    return char.ToLowerInvariant(s[0]) + s.Substring(1, s.Length - 1);
                })
                .Aggregate(string.Empty, (s1, s2) => s1 + s2);

            return str;
        }

        private string GeneratePropName(string str)
        {
            var arr = str.ToCharArray();
            arr[0] = arr[0].ToString().ToUpper()[0];
            str = new string(arr);

            str = str
                .Split('_')
                .Select(s => char.ToUpperInvariant(s[0]) + s.Substring(1, s.Length - 1))
                .Aggregate(string.Empty, (s1, s2) => s1 + s2);

            if (string.Equals(str, Name, StringComparison.OrdinalIgnoreCase))
            {
                str += "_";
            }

            return str;
        }

        private string GenerateType(TDField field)
        {
            string type = field.Type.Name;
            
            var n = field.Type.Name.Count(c => c == '<');
            if (n == 0)
            {
                if (field.Type.Base != null && !string.Equals(field.Type.Base.Name, type, StringComparison.OrdinalIgnoreCase))
                {
                    type = field.Type.Base.Name + "." + type;
                }

                if (builtins.Contains(type))
                {
                    return type;
                }
                
                return GetTypeName(type);
            }
            
            int begin = type.LastIndexOf('<');
            int end = type.IndexOf('>');

            type = type.Substring(begin + 1, end - begin - 1);

            // O_o
            if (field.Type.Generic?.Generic?.Generic?.Base != null) // 3rd generic level
            {
                if (!string.Equals(field.Type.Generic.Generic.Generic.Base.Name, type,
                    StringComparison.OrdinalIgnoreCase))
                {
                    type = field.Type.Generic.Generic.Generic.Base.Name + "." + type;
                }
            }
            else if (field.Type.Generic?.Generic?.Base != null) // 2nd generic level
            {
                if (!string.Equals(field.Type.Generic.Generic.Base.Name, type,
                    StringComparison.OrdinalIgnoreCase))
                {
                    type = field.Type.Generic.Generic.Base.Name + "." + type;
                }
            }
            else if (field.Type.Generic?.Base != null) // 1st generic level
            {
                if (!string.Equals(field.Type.Generic.Base.Name, type,
                    StringComparison.OrdinalIgnoreCase))
                {
                    type = field.Type.Generic.Base.Name + "." + type;
                }
            }

            bool builtin = builtins.Contains(type);
            
            for (int i = 0; i < n; i++)
            {
                type += "[]";
            }

            return builtin ? type : GetTypeName(type);
        }

        private string GetTypeName(string str)
        {
            if (str.Contains('_'))
            {
                return str
                    .Split('_')
                    .Select(s => char.ToUpperInvariant(s[0]) + s.Substring(1, s.Length - 1))
                    .Aggregate(string.Empty, (s1, s2) => s1 + s2);
            }
            else
            {
                var arr = str.ToCharArray();
                arr[0] = arr[0].ToString().ToUpper()[0];
                return new string(arr);
            }
        }
        
        private string[] builtins = new []
        {
            "bool",
            "byte",
            "int",
            "long",
            "Int64",
            "double?",
            "string"
        };
    }
}